{"version":3,"sources":["sick_face.svg","smile_face.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","randomInteger","min","max","range","Math","floor","random","deleteAtIndex","array","index","length","slice","concat","makeCountArray","returnArray","i","makeZeroesArray","findSurroundingHexes","hex","surroundingHexes","anotherHex","push","arrayCopy","element","hPosition","vPosition","App","state","roundsCompleted","zombieHeadHexes","humanOccupiedHexes","zombieOccupiedHexes","vaccinatedOccupiedHexes","numZombieArms","humanCount","vaccinatedCount","zombieCount","history","algorithm","mortality","mortalityNum","vaccination","vaccineEffectiveness","mode","gameStarted","whoseTurn","placeHeadOrArm","currentHeadHex","numArmsRemaining","hiddenHumanHexes","hiddenVaccinatedHexes","infectedVaccinatedHexes","theGraph","start","bind","nextRound","nextRoundHotseat","restart","handleInputChange","handleHexClick","calcNewInfections","autofill","autofillZombies","autofillHumans","stateObject","theHexagons","theHumans","theVaccinated","theZombies","moreShapes","faces","j","h","sqrt","k","pointsString","id","points","key","style","fill","stroke","strokeWidth","onClick","this","includes","x","y","fontFamily","fontSize","src","sick_face","alt","left","top","smile_face","arm","h2","k2","x1","y1","x2","y2","opacity","cx","cy","r","viewBox","theButtons","theNumInputs","nextRoundButtonTextColor","slideButtonColor","slotsButtonColor","mortalityNumInput","vaccinationNumInputs","otherOptions","className","color","type","value","name","onChange","checked","mortalityColItem","vaccinationColItems","whoseTurnTextColor","currentlyPlacingTypeColor","currentlyPlacingType","headOrArmInfo","currentlyPlacingName","currentlyPlacingNum","split","join","waitEndMessage","normalInfections","newInfections","string0","string1","vaccinationPart","historyTableRows","round","vaccinatedCountData","removedCountData","removedNum","vaccinatedTableHeader","removedTableHeader","historyTable","humanData","zombieData","vaccinatedData","removedData","totalPopulation","theNumber","removedCount","width","height","data","dataKey","e","property","target","Number","setState","selectedHex","findIndex","theSurroundingHexes","numArmOptions","sort","a","b","setTimeout","startHistory","humanUnoccupiedHexes","zombieUnoccupiedHexes","startHumans","startVaccinated","startHumanHexes","startVaccinatedHexes","startUnoccupied","chosenIndex","chosenHex","startZombies","startZombieHexes","startZombieHeads","armOptions","theArmIndices","theArmHexes","randomHeadAlgorithm","suboptimalHexes","breakFlag","placeZombie","arrangeZombie","hexArray","numArms","count","newArms","otherHex","findViableZombie","reqHex","otherHexes","returnThis","currentHexes","setNextArm","armsLeft","console","log","moveHex","currentHex","targetHex","suboptHexes","zombiePositions","currentArms","returnObject","newHexPosition","currentArmHexes","selectedHexResult","horizontalDifference","verticalDifference","options","abs","selectHex","direction","armIndex","aroundSelectedHex","headHex","selectedZombieHexes","newZombieHexes","newHeadResult","viableZombie","chosenArmHexes","chosenArmIndex","targetForHead","allZombieHexes","moveHeadResult","i_","moveArmResult","smallArray","bigArray","isASubset","arrangeZombieResult","slideAlgorithm","headPosition","slotArray","currentSlots","chosenSlot","chosenHead","chosenArms","slotsAlgorithm","inputObject","newVaccinatedInfections","createGraph","displayBoard","displayControls","displayStatusInfo","displayHistoryTable","href","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.46216a71.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/sick_face.5f93c0fb.svg\";","module.exports = __webpack_public_path__ + \"static/media/smile_face.0a29229c.svg\";","import React from 'react';\r\nimport sick_face from './sick_face.svg';\r\nimport smile_face from './smile_face.svg';\r\nimport { LineChart, Line, CartesianGrid, XAxis, YAxis } from 'recharts';\r\n\r\nclass App extends React.Component {\r\n\tconstructor() {\r\n        super();\r\n        this.state = {\r\n            roundsCompleted: 0,\r\n            zombieHeadHexes: makeZeroesArray(100),\r\n            humanOccupiedHexes: [],\r\n            zombieOccupiedHexes: [],\r\n            vaccinatedOccupiedHexes: [],\r\n            numZombieArms: 2,\r\n            humanCount: 50,\r\n            vaccinatedCount: 0,\r\n            zombieCount: 1,\r\n            history: [],\r\n            algorithm: \"random-head\",\r\n            mortality: false,\r\n            mortalityNum: 1,\r\n            vaccination: false,\r\n            vaccineEffectiveness: 80,\r\n            mode: \"auto\",\r\n            gameStarted: false,\r\n            whoseTurn: \"Humans\",\r\n            placeHeadOrArm: \"head\",\r\n            currentHeadHex: 0,\r\n            numArmsRemaining: 0,\r\n            hiddenHumanHexes: [],\r\n            hiddenVaccinatedHexes: [],\r\n            infectedVaccinatedHexes: [],\r\n            theGraph: null\r\n        }\r\n        this.start = this.start.bind(this)\r\n        this.nextRound = this.nextRound.bind(this);\r\n        this.nextRoundHotseat = this.nextRoundHotseat.bind(this);\r\n        this.restart = this.restart.bind(this);\r\n        this.handleInputChange = this.handleInputChange.bind(this);\r\n        this.handleHexClick = this.handleHexClick.bind(this);\r\n        this.calcNewInfections = this.calcNewInfections.bind(this);\r\n        this.autofill = this.autofill.bind(this);\r\n        this.autofillZombies = this.autofillZombies.bind(this);\r\n        this.autofillHumans = this.autofillHumans.bind(this);\r\n    }\r\n\r\n    displayBoard(stateObject) {\r\n        let theHexagons = []\r\n        let theHumans = []\r\n        let theVaccinated = []\r\n        let theZombies = []\r\n        let moreShapes = []\r\n        let faces = []\r\n        for (let j=0; j<10; j++) { //j==columns\r\n            let h = 0                   //h pushes column down if it's an even column\r\n            if (j%2) h = Math.sqrt(3)/2\r\n            for (let i=0; i<10; i++) { //i==\"rows\"\r\n                let k = i*Math.sqrt(3) + h  //down\r\n                let pointsString = \r\n                    `${1.5*j+.5},${k} ${1.5*j+1.5},${k} ${1.5*j+2},${k+Math.sqrt(3)/2}\r\n                     ${1.5*j+1.5},${k+Math.sqrt(3)} ${1.5*j+.5},${k+Math.sqrt(3)} ${1.5*j},${k+Math.sqrt(3)/2}`\r\n                theHexagons.push(\r\n                    <polygon\r\n                        id={\"hex-\" + j + \"\" + i} points={pointsString} key={1000*j + 100*i} //1\r\n                        style={{fill: \"white\", stroke: \"black\", strokeWidth: \".02\"}} onClick={this.handleHexClick}\r\n                    />\r\n                )\r\n                if (stateObject.humanOccupiedHexes.includes(10*j + i)) {\r\n                    theHumans.push(\r\n                        <text\r\n                            x={1.5*j + .55} y={k+1.3} id={10*j+i} onClick={this.handleHexClick} //2\r\n                            fontFamily=\"Arial\" fontSize=\"1.75px\" fill=\"blue\" key={1000*j+100*i + 1}>x\r\n                        </text>\r\n                    )\r\n                }\r\n                if (stateObject.vaccinatedOccupiedHexes.includes(10*j + i)) {\r\n                    theVaccinated.push(\r\n                        <text\r\n                            x={1.5*j + .55} y={k+1.3} id={10*j+i} onClick={this.handleHexClick} //3\r\n                            fontFamily=\"Arial\" fontSize=\"1.75px\" fill=\"lime\" key={1000*j+100*i + 2}>x\r\n                        </text>\r\n                    )\r\n                    if (stateObject.infectedVaccinatedHexes.includes(10*j + i) && stateObject.zombieOccupiedHexes.includes(10*j + i)) {\r\n                        faces.push(<img src={sick_face} alt=\"sick\" style={{left: (1.5*j + 1.55)*43.226, top: (k+1.3 - .55)*43.226}}></img>)\r\n                    } else if (!stateObject.infectedVaccinatedHexes.includes(10*j + i) && stateObject.zombieOccupiedHexes.includes(10*j + i)) {\r\n                        faces.push(<img src={smile_face} alt=\"healthy\" style={{left: (1.5*j + 1.55)*43.226, top: (k+1.3 - .55)*43.226}}></img>)\r\n                    }\r\n                }\r\n                if (stateObject.zombieHeadHexes[(10*j + i)]) {\r\n                    for (let x=0; x<stateObject.zombieHeadHexes[(10*j + i)].length; x++) { //4-15\r\n                        let arm = stateObject.zombieHeadHexes[(10*j + i)][x]\r\n                        let h2 = 0\r\n                        if (((arm - arm%10)/10)%2) h2 = Math.sqrt(3)/2\r\n                        let k2 = (arm%10)*Math.sqrt(3) + h2\r\n                        moreShapes.push(\r\n                            <line\r\n                                x1={1.5*j + .99} y1={k+.87} x2={1.5*((arm - arm%10)/10) + .99} y2={k2+.87} onClick={this.handleHexClick}\r\n                                style={{stroke: \"red\", strokeWidth: \".25\"}} key={1000*j + 100*i + 2*x + 3} opacity=\"1\" id={10*j+i}\r\n                            />,\r\n                            <circle\r\n                                cx={1.5*((arm - arm%10)/10) + .99} cy={k2+.87} r=\".4\" id={10*j+i} onClick={this.handleHexClick}\r\n                                stroke=\"red\" strokeWidth=\".01\" fill=\"red\" opacity=\"1\" key={1000*j + 100*i + 2*x + 4}\r\n                            />\r\n                        )\r\n                    }\r\n                    theZombies.push(\r\n                        <circle\r\n                            cx={1.5*j + .99} cy={k+.87} r=\".4\" stroke=\"red\" strokeWidth=\".01\" onClick={this.handleHexClick}\r\n                            fill=\"red\" opacity=\"1\" key={1000*j + 100*i + 16} id={10*j+i}\r\n                        /> //16\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        return (\r\n            <div>\r\n                <svg viewBox=\"0 0 15.5 18.5\">\r\n                    {theHexagons}\r\n                    {theZombies}\r\n                    {moreShapes}\r\n                    {theHumans}\r\n                    {theVaccinated}\r\n                </svg>\r\n                {faces}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    displayControls(stateObject) {\r\n        let theButtons = []\r\n        let theNumInputs = []\r\n        let nextRoundButtonTextColor = \"black\"\r\n        if ((stateObject.humanCount===0 && stateObject.vaccinatedCount===0) || stateObject.zombieCount===0) {\r\n            nextRoundButtonTextColor = \"gray\"\r\n        }\r\n        let slideButtonColor = \"black\"\r\n        if (stateObject.numZombieArms>2) slideButtonColor = \"gray\"\r\n        let slotsButtonColor = \"black\"\r\n        if (stateObject.numZombieArms>4) slotsButtonColor = \"gray\"\r\n        let mortalityNumInput = null\r\n        let vaccinationNumInputs = null\r\n        let otherOptions = null\r\n        if (!stateObject.gameStarted) { //game not started\r\n            if (stateObject.mortality) { \r\n                mortalityNumInput = [\r\n                    <input\r\n                        type=\"number\" className=\"num-input\" id=\"mortality-num\" key=\"0\" min=\"1\"\r\n                        value={stateObject.mortalityNum} name=\"mortalityNum\" onChange={this.handleInputChange}\r\n                    />\r\n                ]\r\n            }\r\n            if (stateObject.vaccination) { \r\n                vaccinationNumInputs = [\r\n                    <input\r\n                        type=\"number\" className=\"num-input\" id=\"vaccinated-start-count\" key=\"0\" min=\"0\" max={100-stateObject.humanCount}\r\n                        value={stateObject.vaccinatedCount} name=\"vaccinatedCount\" onChange={this.handleInputChange}\r\n                    />,\r\n                    <input\r\n                        type=\"number\" className=\"num-input\" id=\"vaccine-effectiveness\" key=\"0\" min=\"0\" max=\"100\"\r\n                        value={stateObject.vaccineEffectiveness} name=\"vaccineEffectiveness\" onChange={this.handleInputChange}\r\n                    />\r\n                ]\r\n            }\r\n            theButtons = <button onClick={this.start}>start</button>\r\n            theNumInputs = [\r\n                <input\r\n                    type=\"number\" className=\"num-input\" id=\"human-start-count\" key=\"0\" min=\"0\" max={100-stateObject.vaccinatedCount}\r\n                    value={stateObject.humanCount} name=\"humanCount\" onChange={this.handleInputChange}\r\n                />,\r\n                <input\r\n                    type=\"number\" className=\"num-input\" id=\"zombie-start-count\" key=\"1\" min=\"1\" max=\"100\"\r\n                    value={stateObject.zombieCount} name=\"zombieCount\" onChange={this.handleInputChange}\r\n                />,\r\n                <input\r\n                    type=\"number\" className=\"num-input\" id=\"num-zombie-arms\" key=\"2\" min=\"0\" max=\"6\"\r\n                    value={stateObject.numZombieArms} name=\"numZombieArms\" onChange={this.handleInputChange}\r\n                />\r\n            ]\r\n            otherOptions = [\r\n                <div className=\"col-item\" key=\"7\">\r\n                    <label>Other Options</label>\r\n                    <div id=\"other-options\">\r\n                        <div>\r\n                            <label>\r\n                                <input\r\n                                    type=\"checkbox\" value={!stateObject.mortality} checked={stateObject.mortality} \r\n                                    name=\"mortality\" onChange={this.handleInputChange}\r\n                                />Zombie Mortality\r\n                            </label>\r\n                        </div>\r\n                        <div>\r\n                            <label>\r\n                                <input \r\n                                    type=\"checkbox\" value={!stateObject.vaccination} checked={stateObject.vaccination} \r\n                                    name=\"vaccination\" onChange={this.handleInputChange}\r\n                                />Vaccination\r\n                            </label>\r\n                        </div>\r\n                    </div>\r\n                </div>,\r\n                <div className=\"col-item\" key=\"8\">\r\n                    <label>Mode</label>\r\n                    <div id=\"mode-select\">\r\n                        <div>\r\n                            <label>\r\n                                <input\r\n                                    type=\"radio\" value=\"auto\" checked={stateObject.mode===\"auto\"} \r\n                                    name=\"mode\" onChange={this.handleInputChange}\r\n                                />Auto\r\n                            </label>\r\n                        </div>\r\n                        <div>\r\n                            <label>\r\n                                <input \r\n                                    type=\"radio\" value=\"hotseat\" checked={stateObject.mode===\"hotseat\"} \r\n                                    name=\"mode\" onChange={this.handleInputChange}\r\n                                />Hotseat\r\n                            </label>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            ]\r\n        } else { //game started\r\n            if (stateObject.mortality) { \r\n                mortalityNumInput = [<label key=\"0\"><strong>{stateObject.mortalityNum}</strong></label>]\r\n            }\r\n            if (stateObject.vaccination) { \r\n                vaccinationNumInputs = [\r\n                    <label key=\"0\"><strong>{stateObject.history[0].vaccinatedCount}</strong></label>,\r\n                    <label key=\"1\"><strong>{stateObject.vaccineEffectiveness}</strong></label>\r\n                ]\r\n            }\r\n            if (stateObject.mode===\"auto\") {\r\n                theButtons[0] = [\r\n                    <div className=\"col-item\" key=\"0\">\r\n                        <button onClick={this.nextRound} style={{color: nextRoundButtonTextColor}}>next round</button>\r\n                    </div>\r\n                ]\r\n            } else if (stateObject.whoseTurn===\"wait\") {\r\n                theButtons[0] = [\r\n                    <div className=\"col-item\" key=\"0\">\r\n                        <button onClick={this.nextRoundHotseat} style={{color: nextRoundButtonTextColor}}>next round</button>\r\n                    </div>\r\n                ]\r\n            } else if (stateObject.mode===\"hotseat\") {\r\n                theButtons[0] = [\r\n                    <div className=\"col-item\" key=\"0\">\r\n                        <button onClick={this.autofill}>autofill</button>\r\n                    </div>\r\n                ]\r\n            }\r\n            theButtons[1] = [\r\n                <div className=\"col-item\" key=\"1\">\r\n                    <button onClick={this.restart}>restart</button>\r\n                </div>\r\n            ]\r\n            theNumInputs = [\r\n                <label key=\"0\"><strong>{stateObject.history[0].humanCount}</strong></label>,\r\n                <label key=\"1\"><strong>{stateObject.history[0].zombieCount}</strong></label>,\r\n                <label key=\"2\"><strong>{stateObject.numZombieArms}</strong></label>\r\n            ]\r\n        }\r\n        let mortalityColItem = null\r\n        if (stateObject.mortality) {\r\n            mortalityColItem = [\r\n                <div className=\"col-item\" key=\"3\">\r\n                    <label>Zombie Lifespan (days)</label>\r\n                    {mortalityNumInput}\r\n                </div>\r\n            ]\r\n        }\r\n        let vaccinationColItems = null\r\n        if (stateObject.vaccination) {\r\n            vaccinationColItems = [\r\n                <div className=\"col-item\" key=\"4\">\r\n                    <label>Vaccinated Human Start Count</label>\r\n                    {vaccinationNumInputs[0]}\r\n                </div>,\r\n                <div className=\"col-item\" key=\"5\">\r\n                    <label>% Vaccine Effectiveness</label>\r\n                    {vaccinationNumInputs[1]}\r\n                </div>\r\n            ]\r\n        }\r\n\r\n        return (\r\n            <div id=\"controls\">\r\n                <div id=\"col-0\" className=\"column\"> {/* buttons*/}\r\n                    {theButtons}\r\n                </div>\r\n                <div id=\"col-1\" className=\"column\"> {/*initial condition settings*/}\r\n                    <div className=\"col-item\" key=\"0\">\r\n                        <label>Human Start Count</label>\r\n                        {theNumInputs[0]}\r\n                    </div>\r\n                    <div className=\"col-item\" key=\"1\">\r\n                        <label>Zombie Start Count</label>\r\n                        {theNumInputs[1]}\r\n                    </div>\r\n                    <div className=\"col-item\" key=\"2\">\r\n                        <label># of Zombie Arms</label>\r\n                        {theNumInputs[2]}\r\n                    </div>\r\n                    {mortalityColItem}\r\n                    {vaccinationColItems}\r\n                    <div className=\"col-item\" key=\"6\">\r\n                        <label>Algorithm</label>\r\n                        <div id=\"algorithm-select\">\r\n                            <div>\r\n                                <label>\r\n                                    <input\r\n                                        type=\"radio\" value=\"random-head\" checked={stateObject.algorithm==='random-head'} \r\n                                        name=\"algorithm\" onChange={this.handleInputChange}\r\n                                    />Random Head\r\n                                </label>\r\n                            </div>\r\n                            <div>\r\n                                <label style={{color: slideButtonColor}}>\r\n                                    <input \r\n                                        type=\"radio\" value=\"slide\" checked={stateObject.algorithm==='slide'} \r\n                                        name=\"algorithm\" onChange={this.handleInputChange}\r\n                                    />Slide\r\n                                </label>\r\n                            </div>\r\n                            <div>\r\n                                <label style={{color: slotsButtonColor}}>\r\n                                    <input \r\n                                        type=\"radio\" value=\"slots\" checked={stateObject.algorithm==='slots'}\r\n                                        name=\"algorithm\" onChange={this.handleInputChange}\r\n                                    />Slots\r\n                                </label>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                    {otherOptions}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    displayStatusInfo(stateObject) {\r\n        if (!stateObject.gameStarted) return null\r\n        if (stateObject.whoseTurn===\"Humans\" || stateObject.whoseTurn===\"Zombies\") {\r\n            let whoseTurnTextColor;\r\n            let currentlyPlacingTypeColor;\r\n            let currentlyPlacingType;\r\n            let headOrArmInfo = null;\r\n            if (stateObject.whoseTurn===\"Humans\") {\r\n                whoseTurnTextColor = \"blue\"\r\n                if (stateObject.humanCount>0) {\r\n                   currentlyPlacingType = \"human\"\r\n                   currentlyPlacingTypeColor = \"blue\"\r\n                } else if (stateObject.vaccinatedCount>0) {\r\n                    currentlyPlacingType = \"vaccinated human\"\r\n                    currentlyPlacingTypeColor = \"lime\"\r\n                } else {\r\n                    return (\r\n                        <div id=\"status-info\" className=\"column\">\r\n                            <p><strong>Switch players!</strong></p>\r\n                        </div>\r\n                    )\r\n                }\r\n            } else if (stateObject.whoseTurn===\"Zombies\") {\r\n                whoseTurnTextColor = \"red\"\r\n                if (stateObject.zombieCount>0) {\r\n                    currentlyPlacingType = \"zombie\"\r\n                    currentlyPlacingTypeColor = \"red\"\r\n                    if (stateObject.placeHeadOrArm===\"head\") {\r\n                        headOrArmInfo = \"the head of \"\r\n                    } else if (stateObject.placeHeadOrArm===\"arm\") {\r\n                        headOrArmInfo = `arm #${stateObject.numZombieArms-stateObject.numArmsRemaining + 1} of `\r\n                    }\r\n                }\r\n            }\r\n            let currentlyPlacingName = currentlyPlacingType + \"Count\"\r\n            currentlyPlacingName = currentlyPlacingName.split(\" human\").join(\"\") //\"zombieCount\" => \"zombieCount\"; \"vaccinated humanCount\" => \"vaccinatedCount\"\r\n            let currentlyPlacingNum = stateObject[currentlyPlacingName]\r\n            return (\r\n                <div id=\"status-info\" className=\"column\">\r\n                    <p><strong style={{color: whoseTurnTextColor}}>{stateObject.whoseTurn}'</strong> turn!</p>\r\n                    <p>Currently placing {headOrArmInfo}<strong style={{color: currentlyPlacingTypeColor}}>\r\n                        {currentlyPlacingType} #{stateObject.history[stateObject.roundsCompleted][currentlyPlacingName] - currentlyPlacingNum + 1}\r\n                        </strong>!</p>\r\n                    <p>\r\n                        You have {currentlyPlacingNum} <strong style={{color: currentlyPlacingTypeColor}}>\r\n                            {currentlyPlacingType + ((currentlyPlacingNum===1 && \" \") || \"s\")}\r\n                        </strong> left to place.\r\n                    </p>\r\n                </div>\r\n            )\r\n        } else if (stateObject.whoseTurn===\"wait\") {\r\n            let waitEndMessage = [<p key=\"0\"><strong>Switch players!</strong></p>]\r\n            if (stateObject.humanCount===0 && stateObject.vaccinatedCount===0) {\r\n                waitEndMessage = [<p key=\"0\"><strong style={{color: \"red\"}}>The Zombies win!</strong></p>]\r\n            } else if (stateObject.zombieCount===0) {\r\n                waitEndMessage = [<p key=\"0\"><strong style={{color: \"blue\"}}>The Humans win!</strong></p>]\r\n            } else if (stateObject.mode===\"auto\") waitEndMessage = null\r\n            let normalInfections = (\r\n                stateObject.history[stateObject.roundsCompleted].newInfections -\r\n                stateObject.infectedVaccinatedHexes.length\r\n            )\r\n            let vaccinatedInfections = stateObject.infectedVaccinatedHexes.length\r\n            let string0 = \"humans were\"\r\n            if (normalInfections===1) string0 = \"human was\"\r\n            let string1 = \"humans were\"\r\n            if (vaccinatedInfections===1) string1 = \"human was\"\r\n            let vaccinationPart = \"\"\r\n            if (stateObject.vaccination) {\r\n                vaccinationPart = ` and ${stateObject.infectedVaccinatedHexes.length} vaccinated ${string1} infected`\r\n            }\r\n\r\n            return (\r\n                <div id=\"status-info\" className=\"column\">\r\n                    <p>Round ended. {normalInfections} normal {string0} infected{vaccinationPart}.\r\n                    </p>\r\n                    {waitEndMessage}\r\n                </div>\r\n            )\r\n        }\r\n    }\r\n\r\n    displayHistoryTable(history, gameStarted) {\r\n        if (gameStarted) {\r\n            let historyTableRows = []\r\n            for (let round in history) {\r\n                let vaccinatedCountData = null\r\n                if (this.state.vaccination) vaccinatedCountData = [\r\n                    <td key={round}>{history[round].vaccinatedCount}</td>\r\n                ]\r\n                let removedCountData = null\r\n                if (this.state.mortality) {\r\n                    let totalPopulation = history[0].zombieCount + history[0].humanCount + history[0].vaccinatedCount\r\n                    let currentOtherPop = history[round].zombieCount + history[round].humanCount + history[round].vaccinatedCount\r\n                    let removedNum = totalPopulation - currentOtherPop\r\n                    removedCountData = [\r\n                        <td key={round}>{removedNum}</td>\r\n                    ]\r\n                }\r\n                historyTableRows.push(\r\n                    <tr key={round}>\r\n                        <td>{round}</td>\r\n                        <td>{history[round].humanCount}</td>\r\n                        {vaccinatedCountData}\r\n                        <td>{history[round].zombieCount}</td>\r\n                        {removedCountData}\r\n                        <td>{history[round].newInfections}</td>\r\n                    </tr>\r\n                )\r\n            }\r\n            let vaccinatedTableHeader = null\r\n            if (this.state.vaccination) vaccinatedTableHeader = [<th key=\"0\"># Vaccinated</th>]\r\n            let removedTableHeader = null\r\n            if (this.state.mortality) removedTableHeader = [<th key=\"0\"># Removed</th>]\r\n            let historyTable = [\r\n                <table key=\"0\">\r\n                    <tbody>\r\n                        <tr>\r\n                            <th>Round #</th>\r\n                            <th># Humans</th>\r\n                            {vaccinatedTableHeader}\r\n                            <th># Zombies</th>\r\n                            {removedTableHeader}\r\n                            <th>New Infections</th>\r\n                        </tr>\r\n                        {historyTableRows}\r\n                    </tbody>\r\n                </table>\r\n            ]\r\n            return (\r\n                <div>\r\n                    {historyTable}\r\n                </div>\r\n            )\r\n        } else return null\r\n    }\r\n\r\n    createGraph(history, vaccination, mortality) {\r\n        let humanData = []\r\n        for (let round in history) { //humanCounts\r\n            humanData.push({round: round, humanCount: history[round].humanCount})\r\n        }\r\n        let zombieData = []\r\n        for (let round in history) { //zombieCounts\r\n            zombieData.push({round: round, zombieCount: history[round].zombieCount})\r\n        }\r\n        if (vaccination) {\r\n            let vaccinatedData = []\r\n            for (let round in history) { //vaccinatedCounts\r\n                vaccinatedData.push({round: round, vaccinatedCount: history[round].vaccinatedCount})\r\n            }\r\n        }\r\n        if (mortality) {\r\n            let removedData = []\r\n            let totalPopulation = history[0].zombieCount + history[0].humanCount + history[0].vaccinatedCount\r\n            for (let round in history) { //removed\r\n                let currentOtherPop = history[round].zombieCount + history[round].humanCount + history[round].vaccinatedCount\r\n                let theNumber = totalPopulation - currentOtherPop\r\n                removedData.push({round: round, removedCount: theNumber})\r\n            }\r\n        }\r\n        const data = [{round: 0, humanCount: 400, zombieCount: 100}, {round: 1, humanCount: 300, zombieCount: 200}];\r\n\r\n        return (\r\n            [\r\n                <div id=\"graph\" key=\"0\">\r\n                    <LineChart width={700} height={300} data={data}>\r\n                        <Line type=\"monotone\" dataKey=\"humanCount\" stroke=\"#8884d8\" />\r\n                        <Line type=\"monotone\" dataKey=\"zombieCount\" stroke=\"#000000\" />\r\n                        <CartesianGrid stroke=\"#ccc\" />\r\n                        <XAxis dataKey=\"round\" />\r\n                        <YAxis />\r\n                    </LineChart>\r\n                </div>\r\n            ]\r\n        )   \r\n    }\r\n\r\n    handleInputChange(e) {\r\n        let property = e.target.name\r\n        let value = e.target.value\r\n        if (e.target.type===\"number\") { \r\n            value = Number(value)                                        //if it's a number we don't want it to be a string\r\n            if (property!==\"vaccineEffectiveness\") value = value-value%1 //the effectiveness can be a decimal\r\n            if (value<e.target.min) value = Number(e.target.min)         //don't let it go below min\r\n            else if (e.target.max && value>e.target.max) value = Number(e.target.max) //or above max\r\n        }\r\n        if (e.target.type===\"checkbox\") {\r\n            value = (value===\"true\")\r\n            if (property===\"vaccination\" && value) { //revert human count if it's too high\r\n                this.setState({vaccinatedCount: 25})\r\n                if (this.state.humanCount>75) this.setState({humanCount: 75})\r\n            } else if (property===\"vaccination\" && !value) this.setState({vaccinatedCount: 0})\r\n        }\r\n        this.setState({[property]: value})\r\n    }\r\n\r\n    componentDidUpdate() { //verifies some settings and inputs\r\n        let stateObject = this.state\r\n        if (\r\n            (stateObject.numZombieArms>4 && stateObject.algorithm!==\"random-head\") ||\r\n            (stateObject.numZombieArms>2 && stateObject.algorithm===\"slide\")\r\n        ) this.setState({algorithm: \"random-head\"})\r\n    }\r\n\r\n    handleHexClick(e) {\r\n        let stateObject = this.state\r\n        if (!stateObject.gameStarted || stateObject.mode===\"auto\") return\r\n        let selectedHex = Number(e.target.id.slice(-2))\r\n        if (\r\n            stateObject.whoseTurn===\"Humans\" &&\r\n            !stateObject.humanOccupiedHexes.includes(selectedHex) &&\r\n            !stateObject.vaccinatedOccupiedHexes.includes(selectedHex)\r\n            ) {\r\n                if (stateObject.humanCount > 0) {\r\n                    let humanOccupiedHexes = stateObject.humanOccupiedHexes\r\n                    humanOccupiedHexes.push(selectedHex)\r\n                    this.setState(\r\n                        {\r\n                            humanOccupiedHexes: humanOccupiedHexes.sort((a,b) => a-b),\r\n                            humanCount: stateObject.humanCount - 1\r\n                        }\r\n                    )\r\n                } else if (stateObject.vaccinatedCount > 0) {\r\n                    let vaccinatedOccupiedHexes = stateObject.vaccinatedOccupiedHexes\r\n                    vaccinatedOccupiedHexes.push(selectedHex)\r\n                    this.setState(\r\n                        {\r\n                            vaccinatedOccupiedHexes: vaccinatedOccupiedHexes.sort((a,b) => a-b),\r\n                            vaccinatedCount: stateObject.vaccinatedCount - 1\r\n                        }\r\n                    )\r\n                }\r\n                if (stateObject.humanCount + stateObject.vaccinatedCount===1) { //this means we just placed our last human\r\n                    setTimeout(() => {\r\n                            this.setState(\r\n                                {\r\n                                    whoseTurn: \"Zombies\",\r\n                                    hiddenHumanHexes: stateObject.humanOccupiedHexes,\r\n                                    hiddenVaccinatedHexes: stateObject.vaccinatedOccupiedHexes,\r\n                                    humanOccupiedHexes: [],\r\n                                    vaccinatedOccupiedHexes: []\r\n                                }\r\n                            )\r\n\r\n                        }, 1500\r\n                    )\r\n                }\r\n        } else if (\r\n            stateObject.whoseTurn===\"Zombies\" &&\r\n            !stateObject.zombieOccupiedHexes.includes(selectedHex)\r\n            ) {\r\n                let zombieCount = stateObject.zombieCount\r\n                if (stateObject.placeHeadOrArm===\"head\") {\r\n                    let zombieOccupiedHexes = stateObject.zombieOccupiedHexes\r\n                    let zombieHeadHexes = stateObject.zombieHeadHexes\r\n                    zombieOccupiedHexes.push(selectedHex)\r\n                    zombieHeadHexes[selectedHex] = []\r\n\r\n                    //calculate how many arm opts there are\r\n                    let theSurroundingHexes = findSurroundingHexes(selectedHex)\r\n                    let numArmOptions = 0\r\n                    for (let hex of theSurroundingHexes) {\r\n                        if (!zombieOccupiedHexes.includes(hex)) numArmOptions++\r\n                    }\r\n                    let placeHeadOrArm = \"arm\"\r\n                    if (numArmOptions===0 || stateObject.numZombieArms===0) {\r\n                        placeHeadOrArm = \"head\"\r\n                        zombieCount--\r\n                    }\r\n\r\n                    this.setState(\r\n                        {\r\n                            zombieOccupiedHexes: zombieOccupiedHexes.sort((a,b) => a-b),\r\n                            zombieHeadHexes: zombieHeadHexes,\r\n                            zombieCount: zombieCount,\r\n                            placeHeadOrArm: placeHeadOrArm,\r\n                            numArmsRemaining: stateObject.numZombieArms,\r\n                            currentHeadHex: selectedHex\r\n                        }\r\n                    )\r\n                } else if (stateObject.placeHeadOrArm===\"arm\") {\r\n                    let zombieOccupiedHexes = stateObject.zombieOccupiedHexes\r\n                    let zombieHeadHexes = stateObject.zombieHeadHexes\r\n                    let currentHeadHex = stateObject.currentHeadHex\r\n                    let numArmsRemaining = stateObject.numArmsRemaining\r\n\r\n                    if (!findSurroundingHexes(currentHeadHex).includes(selectedHex)) return\r\n\r\n                    zombieOccupiedHexes.push(selectedHex)\r\n                    zombieHeadHexes[currentHeadHex].push(selectedHex)\r\n                    numArmsRemaining--\r\n\r\n                    //calculate how many arm opts there are\r\n                    let theSurroundingHexes = findSurroundingHexes(currentHeadHex)\r\n                    let numArmOptions = 0\r\n                    for (let hex of theSurroundingHexes) {\r\n                        if (!zombieOccupiedHexes.includes(hex)) numArmOptions++\r\n                    }\r\n                    let placeHeadOrArm = \"arm\"\r\n                    if (numArmOptions===0 || numArmsRemaining===0) {\r\n                        placeHeadOrArm = \"head\"\r\n                        zombieCount--\r\n                    }\r\n\r\n                    this.setState(\r\n                        {\r\n                            zombieOccupiedHexes: zombieOccupiedHexes.sort((a,b) => a-b),\r\n                            zombieHeadHexes: zombieHeadHexes,\r\n                            zombieCount: zombieCount,\r\n                            placeHeadOrArm: placeHeadOrArm,\r\n                            numArmsRemaining: numArmsRemaining\r\n                        }\r\n                    )\r\n                }\r\n                if (zombieCount===0) {\r\n                    this.setState(\r\n                        {\r\n                            whoseTurn: \"wait\",\r\n                            humanOccupiedHexes: stateObject.hiddenHumanHexes,\r\n                            vaccinatedOccupiedHexes: stateObject.hiddenVaccinatedHexes\r\n                        }\r\n                    )\r\n                    this.calcNewInfections(this.state)\r\n                }\r\n        } else if (stateObject.whoseTurn===\"Humans\") { //deleting a human\r\n            if (stateObject.humanCount===0 && stateObject.vaccinatedCount===0) return\r\n            if (stateObject.humanOccupiedHexes.includes(selectedHex)) {\r\n                let humanOccupiedHexes = stateObject.humanOccupiedHexes\r\n                humanOccupiedHexes = deleteAtIndex(\r\n                    humanOccupiedHexes, \r\n                    humanOccupiedHexes.findIndex(element => element===selectedHex)\r\n                )\r\n                this.setState(\r\n                    {\r\n                        humanCount: stateObject.humanCount + 1,\r\n                        humanOccupiedHexes: humanOccupiedHexes\r\n                    }\r\n                )\r\n            } else if (stateObject.vaccinatedOccupiedHexes.includes(selectedHex)) {\r\n                let vaccinatedOccupiedHexes = stateObject.vaccinatedOccupiedHexes\r\n                vaccinatedOccupiedHexes = deleteAtIndex(\r\n                    vaccinatedOccupiedHexes, \r\n                    vaccinatedOccupiedHexes.findIndex(element => element===selectedHex)\r\n                )\r\n                this.setState(\r\n                    {\r\n                        vaccinatedCount: stateObject.vaccinatedCount + 1,\r\n                        vaccinatedOccupiedHexes: vaccinatedOccupiedHexes\r\n                    }\r\n                )\r\n            }\r\n        } else if (stateObject.whoseTurn===\"Zombies\") { //deleting a zombie\r\n            let zombieHeadHexes = stateObject.zombieHeadHexes\r\n            let zombieOccupiedHexes = stateObject.zombieOccupiedHexes\r\n            if (zombieOccupiedHexes.includes(selectedHex) && zombieHeadHexes[selectedHex]) {\r\n                zombieOccupiedHexes = deleteAtIndex(\r\n                    zombieOccupiedHexes, \r\n                    zombieOccupiedHexes.findIndex(element => element===selectedHex)\r\n                )\r\n                for (let arm of zombieHeadHexes[selectedHex]) {\r\n                    zombieOccupiedHexes = deleteAtIndex(\r\n                        zombieOccupiedHexes, \r\n                        zombieOccupiedHexes.findIndex(element => element===arm)\r\n                    )\r\n                }\r\n                zombieHeadHexes[selectedHex] = 0\r\n                let zombieCount = stateObject.zombieCount\r\n                let placeHeadOrArm = stateObject.placeHeadOrArm\r\n                if (selectedHex===stateObject.currentHeadHex) placeHeadOrArm = \"head\"\r\n                else zombieCount++\r\n                this.setState(\r\n                    {\r\n                        zombieCount: zombieCount,\r\n                        zombieHeadHexes: zombieHeadHexes,\r\n                        zombieOccupiedHexes: zombieOccupiedHexes,\r\n                        placeHeadOrArm: placeHeadOrArm\r\n                    }\r\n                )\r\n            }\r\n        }   \r\n    }\r\n\r\n    start() {\r\n        let stateObject = this.state\r\n        let vaccinatedCount = stateObject.vaccinatedCount\r\n        let humanCount = stateObject.humanCount\r\n        let zombieCount = stateObject.zombieCount\r\n        let history = []\r\n        history[0] = {\r\n                humanCount: humanCount,\r\n                vaccinatedCount: vaccinatedCount,\r\n                zombieCount: zombieCount,\r\n                newInfections: zombieCount\r\n            }\r\n\r\n        this.setState({history: history, gameStarted: true})\r\n\r\n        if (stateObject.mode===\"auto\") {\r\n            this.nextRound(history, true)\r\n            this.setState({whoseTurn: \"wait\"})\r\n        }\r\n    }\r\n\r\n    nextRound(startHistory) {\r\n        let stateObject = this.state\r\n        if ((stateObject.humanCount===0 && stateObject.vaccinatedCount===0) || stateObject.zombieCount===0) return\r\n        let humanCount = stateObject.humanCount\r\n        let zombieCount = stateObject.zombieCount\r\n        let vaccinatedCount = stateObject.vaccinatedCount\r\n        let history = stateObject.history\r\n        if (history.length===0) history = startHistory\r\n\r\n        let autofillHumans = this.autofillHumans(\r\n            humanCount,\r\n            vaccinatedCount,\r\n            [],\r\n            [],\r\n            makeCountArray(100)\r\n        )\r\n        let humanOccupiedHexes = autofillHumans.humanOccupiedHexes\r\n        let vaccinatedOccupiedHexes = autofillHumans.vaccinatedOccupiedHexes\r\n\r\n        let autofillZombies = this.autofillZombies(\r\n            zombieCount,\r\n            [],\r\n            makeZeroesArray(100),\r\n            makeCountArray(100)\r\n        )\r\n        let zombieOccupiedHexes = autofillZombies.zombieOccupiedHexes\r\n        let zombieHeadHexes = autofillZombies.zombieHeadHexes\r\n\r\n        this.calcNewInfections(\r\n            {\r\n                humanCount: humanCount,\r\n                vaccinatedCount: vaccinatedCount,\r\n                zombieCount: zombieCount,\r\n                humanOccupiedHexes: humanOccupiedHexes,\r\n                vaccinatedOccupiedHexes: vaccinatedOccupiedHexes,\r\n                zombieOccupiedHexes: zombieOccupiedHexes,\r\n                history: history,\r\n            }\r\n        )\r\n\r\n        this.setState(\r\n            {\r\n                humanOccupiedHexes: humanOccupiedHexes.sort((a, b) => a-b),\r\n                vaccinatedOccupiedHexes: vaccinatedOccupiedHexes,\r\n                zombieHeadHexes: zombieHeadHexes,\r\n                zombieOccupiedHexes: zombieOccupiedHexes\r\n            }\r\n        )\r\n    }\r\n\r\n    autofill() {\r\n        let stateObject = this.state\r\n        let whoseTurn = stateObject.whoseTurn\r\n        if (whoseTurn===\"Humans\") {\r\n            let humanUnoccupiedHexes = []\r\n            for (let i=0; i<100; i++) {\r\n                if (!stateObject.humanOccupiedHexes.includes(i) && !stateObject.vaccinatedOccupiedHexes.includes(i)) {\r\n                    humanUnoccupiedHexes.push(i)\r\n                }\r\n            }\r\n            this.autofillHumans(\r\n                stateObject.humanCount,\r\n                stateObject.vaccinatedCount,\r\n                stateObject.humanOccupiedHexes,\r\n                stateObject.vaccinatedOccupiedHexes,\r\n                humanUnoccupiedHexes\r\n            )\r\n        } else if (whoseTurn===\"Zombies\") {\r\n            let zombieUnoccupiedHexes = []\r\n            for (let i=0; i<100; i++) {\r\n                if (!stateObject.zombieOccupiedHexes.includes(i)) {\r\n                    zombieUnoccupiedHexes.push(i)\r\n                }\r\n            }\r\n            this.autofillZombies(\r\n                stateObject.zombieCount,\r\n                stateObject.zombieOccupiedHexes,\r\n                stateObject.zombieHeadHexes,\r\n                zombieUnoccupiedHexes\r\n            )\r\n        }\r\n    }\r\n\r\n    autofillHumans(startHumans, startVaccinated, startHumanHexes, startVaccinatedHexes, startUnoccupied) {\r\n        let stateObject = this.state\r\n        let humanCount = startHumans\r\n        let vaccinatedCount = startVaccinated\r\n        let humanOccupiedHexes = startHumanHexes\r\n        let vaccinatedOccupiedHexes = startVaccinatedHexes\r\n        let humanUnoccupiedHexes = startUnoccupied\r\n\r\n        for (let i=0; i<humanCount; i++) {\r\n            let chosenIndex = randomInteger(0, humanUnoccupiedHexes.length - 1)\r\n            let chosenHex = humanUnoccupiedHexes[chosenIndex]\r\n            humanOccupiedHexes.push(chosenHex)\r\n            humanUnoccupiedHexes = deleteAtIndex(humanUnoccupiedHexes, chosenIndex)\r\n        }\r\n        if (stateObject.vaccination) {\r\n            for (let i=0; i<vaccinatedCount; i++) {\r\n                let chosenIndex = randomInteger(0, humanUnoccupiedHexes.length - 1)\r\n                let chosenHex = humanUnoccupiedHexes[chosenIndex]\r\n                vaccinatedOccupiedHexes.push(chosenHex)\r\n                humanUnoccupiedHexes = deleteAtIndex(humanUnoccupiedHexes, chosenIndex)\r\n            }\r\n        }\r\n        if (stateObject.mode===\"hotseat\") {\r\n            humanCount = 0\r\n            this.setState(\r\n                {\r\n                    humanOccupiedHexes: humanOccupiedHexes,\r\n                    vaccinatedOccupiedHexes: vaccinatedOccupiedHexes,\r\n                    humanCount: humanCount\r\n                }\r\n            )\r\n            setTimeout(() => {\r\n                    this.setState(\r\n                        {\r\n                            whoseTurn: \"Zombies\",\r\n                            hiddenHumanHexes: stateObject.humanOccupiedHexes,\r\n                            hiddenVaccinatedHexes: stateObject.vaccinatedOccupiedHexes,\r\n                            humanOccupiedHexes: [],\r\n                            vaccinatedOccupiedHexes: []\r\n                        }\r\n                    )\r\n                }, 1500\r\n            )\r\n        }\r\n        return {\r\n            humanOccupiedHexes: humanOccupiedHexes,\r\n            vaccinatedOccupiedHexes: vaccinatedOccupiedHexes\r\n        }\r\n    }\r\n\r\n    autofillZombies(startZombies, startZombieHexes, startZombieHeads, startUnoccupied) {\r\n        let stateObject = this.state\r\n        let zombieCount = startZombies\r\n        let numZombieArms = stateObject.numZombieArms\r\n        let zombieOccupiedHexes = startZombieHexes\r\n        let zombieUnoccupiedHexes = startUnoccupied\r\n        let zombieHeadHexes = startZombieHeads\r\n\r\n        function randomHeadAlgorithm() {\r\n            //This is the first algorithm for deciding where to put the zombies.\r\n            //For each zombie:\r\n            //1. A hex is randomly chosen from the set of hexes which are currently unoccupied by other zombies (including their arms).\r\n            //2. Unoccupied hexes which surround the chosen head hex are identified.\r\n            //3. The hexes which will be occupied by the zombie's arms are randomly chosen out of the available surrounding hexes.\r\n            //4. Lists containing information about where zombies are located are updated.\r\n            //Importantly, each zombie can only claim *available hexes* around it. If a zombie runs out of available hexes, it will simply have less (or even zero) arms.\r\n            //This means that sometimes zombies will have less than the selected number of arms when there are no more available spaces around the chosen head.\r\n\r\n            for (let i=0; i<zombieCount; i++) {\r\n                if (zombieUnoccupiedHexes.length===0) break;\r\n                let chosenIndex = randomInteger(0, zombieUnoccupiedHexes.length-1)\r\n                let chosenHex = zombieUnoccupiedHexes[chosenIndex]\r\n    \r\n                let surroundingHexes = findSurroundingHexes(chosenHex)\r\n                let armOptions = []\r\n                for (let hex of surroundingHexes) {\r\n                    if (!zombieOccupiedHexes.includes(hex)) armOptions.push(hex)\r\n                }\r\n                let theArmIndices = []\r\n                let theArmHexes = []\r\n                for (let j=0; j<stateObject.numZombieArms; j++) {\r\n                    if (armOptions.length===0) break;\r\n                    theArmIndices[j] = randomInteger(0, armOptions.length - 1)\r\n                    theArmHexes[j] = armOptions[theArmIndices[j]]\r\n                    armOptions = deleteAtIndex(armOptions, theArmIndices[j])\r\n                }\r\n    \r\n                zombieHeadHexes[chosenHex] = theArmHexes\r\n                zombieOccupiedHexes.push(chosenHex)\r\n                for (let j=0; j<theArmHexes.length; j++) {\r\n                    zombieOccupiedHexes.push(theArmHexes[j])\r\n                    zombieUnoccupiedHexes = deleteAtIndex(\r\n                        zombieUnoccupiedHexes,\r\n                        zombieUnoccupiedHexes.findIndex(element => element===theArmHexes[j])\r\n                    )\r\n                }\r\n                zombieUnoccupiedHexes = deleteAtIndex(\r\n                    zombieUnoccupiedHexes,\r\n                    zombieUnoccupiedHexes.findIndex(element => element===chosenHex)\r\n                )\r\n            }\r\n        }\r\n\r\n        function slideAlgorithm() {\r\n            //This algorithm works similarly to the random head algorithm, with some changes that slow it down,\r\n            //but enable zombies to always have the maximum number of arms, so long as the selected number of arms is 0-2.\r\n            //Differences:\r\n            // * Once a spot for a head is chosen, if there is not a sufficient number of surrounding hexes available,\r\n            //   that hex is added to a new list of suboptimal hexes. A new head hex is chosen randomly that is neither occupied\r\n            //   nor on this new list.\r\n            // * Eventually, unoccupied hexes that are not on the suboptimal list will run out. at that point, a head is chosen along with\r\n            //   two random arms from the list of suboptimal hexes. Zombies in between each arm and the head are progressively moved out of the way so\r\n            //   that the arm hexes can move into contact with the head until they are adjacent.\r\n            // * Once the arm hexes and head hex are adjacent, the new zombie is placed.\r\n            // Importantly, zombies can always be slid out of the way if their arm count is less than 3. With 3 or more arms, the algorithm will not always work\r\n            // and therefore shouldn't be used (zombies with more arms sometimes can't slide cleanly out of the way without disrupting other zombies).\r\n\r\n            let suboptimalHexes = []\r\n            let breakFlag = false\r\n            function placeZombie() {\r\n                if (zombieUnoccupiedHexes.length>0) { //optimal only phase\r\n                    //Choose head hex\r\n                    let chosenIndex = randomInteger(0, zombieUnoccupiedHexes.length-1)\r\n                    let chosenHex = zombieUnoccupiedHexes[chosenIndex]\r\n                    \r\n                    //identify surrounding hexes\r\n                    let surroundingHexes = findSurroundingHexes(chosenHex)\r\n                    let armOptions = []\r\n                    for (let hex of surroundingHexes) {\r\n                        if (!zombieOccupiedHexes.includes(hex)) armOptions.push(hex)\r\n                    }\r\n    \r\n                    if (armOptions.length < numZombieArms) { //if chosenHex is subopt\r\n                        suboptimalHexes.push(chosenHex)\r\n                        zombieUnoccupiedHexes = deleteAtIndex(\r\n                            zombieUnoccupiedHexes,\r\n                            zombieUnoccupiedHexes.findIndex(element => element===chosenHex)\r\n                        )\r\n                        placeZombie() //start over trying to find a spot for this zombie\r\n                    } else {\r\n                        let theArmIndices = []\r\n                        let theArmHexes = []\r\n                        for (let j=0; j<numZombieArms; j++) {\r\n                            if (armOptions.length===0) break;\r\n                            theArmIndices[j] = randomInteger(0, armOptions.length - 1)\r\n                            theArmHexes[j] = armOptions[theArmIndices[j]]\r\n                            armOptions = deleteAtIndex(armOptions, theArmIndices[j])\r\n                        }\r\n            \r\n                        zombieHeadHexes[chosenHex] = theArmHexes\r\n                        zombieOccupiedHexes.push(chosenHex)\r\n                        for (let j=0; j<theArmHexes.length; j++) {\r\n                            zombieOccupiedHexes.push(theArmHexes[j])\r\n                            if (zombieUnoccupiedHexes.includes(theArmHexes[j])) {\r\n                                zombieUnoccupiedHexes = deleteAtIndex(\r\n                                    zombieUnoccupiedHexes,\r\n                                    zombieUnoccupiedHexes.findIndex(element => element===theArmHexes[j])\r\n                                )\r\n                            } else if (suboptimalHexes.includes(theArmHexes[j])) {\r\n                                suboptimalHexes = deleteAtIndex(\r\n                                    suboptimalHexes,\r\n                                    suboptimalHexes.findIndex(element => element===theArmHexes[j])\r\n                                )\r\n                            }\r\n                        }\r\n                        zombieUnoccupiedHexes = deleteAtIndex(\r\n                            zombieUnoccupiedHexes,\r\n                            zombieUnoccupiedHexes.findIndex(element => element===chosenHex)\r\n                        )\r\n                    }\r\n\r\n                } else if (suboptimalHexes.length > 0) { //the only hexes left are suboptimal\r\n                    console.log(\"Ran out of optimal hexes. trying to move these hexes together:\", suboptimalHexes)\r\n                    //move the hexes together\r\n                    //Choose head hex\r\n                    let chosenIndex = randomInteger(0, suboptimalHexes.length-1)\r\n                    let chosenHex = suboptimalHexes[chosenIndex]\r\n                    let chosenArmHexes = []\r\n                    suboptimalHexes = deleteAtIndex(suboptimalHexes, chosenIndex)\r\n                    for (let j = 0; j<numZombieArms; j++) {            //randomly choose new arms\r\n                        if (suboptimalHexes.length>0) { //esc if there aren't enough remaining hexes\r\n                            let chosenArmIndex = randomInteger(0, suboptimalHexes.length - 1)\r\n                            chosenArmHexes.push(suboptimalHexes[chosenArmIndex])\r\n                            suboptimalHexes = deleteAtIndex(suboptimalHexes, chosenArmIndex) //the chosen arm hexes aren't \"empty\" anymore\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    function arrangeZombie(hexArray) { //takes adjacent hexes and outputs the loc of head and arms.\r\n                        let numArms = hexArray.length - 1\r\n                    \r\n                        let count = 0\r\n                        let newArms = []\r\n                        for (let hex of hexArray) {\r\n                            count = 0\r\n                            newArms = []\r\n                            let theSurroundingHexes = findSurroundingHexes(hex)\r\n                            for (let otherHex of hexArray) {\r\n                                if (hex!==otherHex && theSurroundingHexes.includes(otherHex)) {\r\n                                    count++\r\n                                    newArms.push(otherHex)\r\n                                }\r\n                            }\r\n                            if (count===numArms) {\r\n                                return [hex, newArms]\r\n                            }\r\n                        }\r\n                        return false //the hexes are non-adjacent\r\n                    }\r\n\r\n                    function findViableZombie(reqHex, otherHexes, numArms) { //reqHex must be a part of the final zombie (the old hex that should be left behind)\r\n                        let currentHexes = [reqHex]\r\n                        let returnThis;\r\n                        let breakFlag = false\r\n                        \r\n                        function setNextArm(armsLeft) {\r\n                            for (let i=0; i<otherHexes.length; i++) {\r\n                                if (otherHexes[i]!==currentHexes[numArms - armsLeft] && !breakFlag) {\r\n                                    currentHexes[numArms - (armsLeft) + 1] = otherHexes[i]\r\n                                    console.log(currentHexes, arrangeZombie(currentHexes), currentHexes.length===(numArms+1))\r\n                                    if (arrangeZombie(currentHexes) && currentHexes.length===(numArms+1)) {\r\n                                        returnThis = arrangeZombie(currentHexes)\r\n                                        breakFlag = true\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (armsLeft>1) setNextArm(armsLeft - 1)\r\n                            }\r\n                        }\r\n                        setNextArm(numArms)\r\n                        return returnThis\r\n                    }\r\n\r\n                    function selectHex(currentHex, targetHex) {\r\n                        let horizontalDifference = hPosition(targetHex) - hPosition(currentHex)\r\n                        let verticalDifference = vPosition(targetHex) - vPosition(currentHex)\r\n                        let options = []\r\n                        if (horizontalDifference > 0) options.push([currentHex + 10, \"right\"]) //right\r\n                        else if (horizontalDifference < 0) options.push([currentHex - 10, \"left\"]) //left\r\n                        if (verticalDifference > 0) options.push([currentHex + 1, \"down\"]) //down\r\n                        else if (verticalDifference < 0) options.push([currentHex - 1, \"up\"]) //up\r\n                        console.log(\"currentHex:\", currentHex, \"targetHex:\", targetHex)\r\n                        if (options.length===1) return options[0]\r\n                        else if (options.length===2) {\r\n                            if (Math.abs(horizontalDifference) > Math.abs(verticalDifference)) return options[0]\r\n                            else if (Math.abs(horizontalDifference) < Math.abs(verticalDifference)) return options[1]\r\n                            else return options[randomInteger(0, 1)] // to make the code zany and whacky, if two options seem equally viable we'll choose randomly between them\r\n                                                                    //the actual reason is randomness can help prevent some inf loops\r\n                        }\r\n                    }\r\n\r\n                    function moveHex(currentHex, targetHex, suboptHexes, zombiePositions, currentArms) { //start, target, suboptimalHexes, zombieHeadHexes\r\n                        let returnObject = {\r\n                            suboptimalHexes: suboptHexes,\r\n                            zombieHeadHexes: zombiePositions,\r\n                            newHexPosition: currentHex,\r\n                            currentArmHexes: currentArms\r\n                        }\r\n                        let selectedHexResult = selectHex(currentHex, targetHex)\r\n                        let selectedHex = selectedHexResult[0]\r\n                        let direction = selectedHexResult[1]\r\n                        console.log(\"starting hex:\", currentHex, \"target hex:\", targetHex, \"selected hex:\", selectedHex, \"direction:\", direction)\r\n\r\n                        if (suboptHexes.includes(selectedHex)) { //if the hex in the direction is empty, just take that one instead\r\n                            returnObject.suboptimalHexes.push(currentHex)\r\n                            returnObject.newHexPosition = selectedHex \r\n                            returnObject.suboptimalHexes = deleteAtIndex(\r\n                                returnObject.suboptimalHexes, returnObject.suboptimalHexes.findIndex(element => element===selectedHex)\r\n                            )\r\n                            console.log(\"(hex was free)\")\r\n                        } else if (currentArms.includes(selectedHex)) { //if the selected hex is an arm\r\n                            //swap them\r\n                            returnObject.newHexPosition = selectedHex\r\n                            let armIndex = returnObject.currentArmHexes.findIndex(element => element===selectedHex)\r\n                            returnObject.currentArmHexes[armIndex] = currentHex\r\n                            console.log(\"encountered an arm. now the arms are:\", returnObject.currentArmHexes)\r\n                        } else {\r\n                            let aroundSelectedHex = findSurroundingHexes(selectedHex); aroundSelectedHex.push(selectedHex)\r\n                            for (let headHex of aroundSelectedHex) { //check hexes around the selected hex to look for the head of the selected zombie\r\n                                if (zombiePositions[headHex] && (headHex===selectedHex || zombiePositions[headHex].includes(selectedHex))) {\r\n                                    console.log(\"selected zombie head:\", headHex, \"arms:\", zombiePositions[headHex])\r\n                                    let selectedZombieHexes = arrayCopy(zombiePositions[headHex])\r\n                                    selectedZombieHexes.push(headHex)\r\n                                    if (direction===\"up\") selectedZombieHexes = selectedZombieHexes.sort((a, b) => a%10 - b%10)\r\n                                    else if (direction===\"down\") selectedZombieHexes = selectedZombieHexes.sort((a, b) => b%10 - a%10)\r\n                                    else if (direction===\"left\") selectedZombieHexes = selectedZombieHexes.sort((a, b) => a - b)\r\n                                    else if (direction===\"right\") selectedZombieHexes = selectedZombieHexes.sort((a, b) => b - a)\r\n                                    returnObject.zombieHeadHexes[headHex] = 0 //delete old zombie from zombieheadhexes\r\n                                    //------figure out new zombie--------//\r\n                                    let newZombieHexes = deleteAtIndex(selectedZombieHexes, 0) //the new zombie will occupy everything but the newly chosen empty hex\r\n                                    newZombieHexes.push(currentHex) //including where the old empty hex used to be\r\n                                    console.log(\"selectedZombieHexes:\", selectedZombieHexes, \"newZombieHexes:\", newZombieHexes)\r\n                                    let newHeadResult = arrangeZombie(newZombieHexes)\r\n                                    if (!newHeadResult) {\r\n                                        console.log(\"couldn't arrange, trying to findViableZombie...\")\r\n                                        let viableZombie = findViableZombie(currentHex, selectedZombieHexes, numZombieArms)\r\n                                        returnObject.zombieHeadHexes[viableZombie[0]] = viableZombie[1]\r\n                                        for (let hex of selectedZombieHexes) {\r\n                                            if (viableZombie[0]!==hex && !viableZombie[1].includes(hex)) {\r\n                                                returnObject.newHexPosition = hex\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        console.log(\"the new zombie has head\", viableZombie[0], \"and arms\", viableZombie[1])\r\n                                    } else {\r\n                                        returnObject.zombieHeadHexes[newHeadResult[0]] = newHeadResult[1]\r\n                                        returnObject.newHexPosition = selectedZombieHexes[0] //our empty hex has moved\r\n                                    }\r\n\r\n                                    console.log(\"newHexPosition:\", returnObject.newHexPosition, \"suboptimalHexes:\", returnObject.suboptimalHexes)\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        return returnObject\r\n                    }\r\n\r\n                    console.log(\r\n                        \"//-----------------//------------------//\",\r\n                        \"trying to connect arm hexes: \",\r\n                        chosenArmHexes,\r\n                        \"to chosen head hex:\",\r\n                        chosenHex,\r\n                        \"here are the subopt hexes:\",\r\n                        suboptimalHexes\r\n                        )\r\n                        \r\n                    let currentHeadHex = chosenHex\r\n                    let currentArmHexes = chosenArmHexes\r\n                    let surroundingHexes = findSurroundingHexes(chosenHex)\r\n                    let targetForHead = chosenArmHexes[0]\r\n                    let allZombieHexes = arrayCopy(chosenArmHexes); allZombieHexes.push(chosenHex)\r\n\r\n\r\n                    let x = 0\r\n                    while (!arrangeZombie(allZombieHexes) && x<1000) { //until\r\n                        console.log(\"moving the head...\")\r\n                        let moveHeadResult = moveHex(currentHeadHex, targetForHead, suboptimalHexes, zombieHeadHexes, currentArmHexes)\r\n                        suboptimalHexes = moveHeadResult.suboptimalHexes\r\n                        zombieHeadHexes = moveHeadResult.zombieHeadHexes\r\n                        currentHeadHex = moveHeadResult.newHexPosition\r\n                        surroundingHexes = findSurroundingHexes(currentHeadHex)\r\n                        allZombieHexes = arrayCopy(currentArmHexes); allZombieHexes.push(currentHeadHex)\r\n                        if (arrangeZombie(allZombieHexes)) break\r\n                        for (let i_=0; i_<currentArmHexes.length; i_++) {\r\n                            console.log(\"moving arm #\", i_, \"which is hex#:\", currentArmHexes[i_], \"toward currentHeadHex\", currentHeadHex)\r\n                            if (!surroundingHexes.includes(currentArmHexes[i_])) {\r\n                                let moveArmResult = moveHex(currentArmHexes[i_], currentHeadHex, suboptimalHexes, zombieHeadHexes, currentArmHexes)\r\n                                suboptimalHexes = moveArmResult.suboptimalHexes\r\n                                zombieHeadHexes = moveArmResult.zombieHeadHexes\r\n                                currentArmHexes[i_] = moveArmResult.newHexPosition\r\n                                allZombieHexes = arrayCopy(currentArmHexes); allZombieHexes.push(currentHeadHex)\r\n                                if (arrangeZombie(allZombieHexes)) break\r\n                            }\r\n                        }\r\n                        targetForHead = currentArmHexes[0]\r\n                        if (surroundingHexes.includes(targetForHead)) { //if the head has reached its target, change the target by cycling the arms\r\n                            console.log(\"head hex\", currentHeadHex, \"is adjacent to old target \", targetForHead)\r\n                            currentArmHexes.push(currentArmHexes[0])\r\n                            currentArmHexes = currentArmHexes.slice(1, currentArmHexes.length)\r\n                        }\r\n                        console.log(\"new targetForHead:\", targetForHead)\r\n                        x++\r\n                    }\r\n                    if (x>=1000) {\r\n                        console.log(\"inf loop failure. could not connect arm hexes\", currentArmHexes, \"to current head hex\", currentHeadHex)\r\n                        breakFlag = true\r\n                    } else {\r\n                        if (!isASubset(currentArmHexes, surroundingHexes)) {\r\n                            let arrangeZombieResult = arrangeZombie(allZombieHexes)\r\n                            currentHeadHex = arrangeZombieResult[0]\r\n                            currentArmHexes = arrangeZombieResult[1]\r\n                        }\r\n                        console.log(\"success! our new zombie is at hex\", currentHeadHex, \"with arms at\", currentArmHexes)\r\n                        zombieHeadHexes[currentHeadHex] = currentArmHexes\r\n                    }\r\n                } else {\r\n                    breakFlag = true\r\n                }\r\n            }\r\n\r\n            for (let i=0; i<zombieCount; i++) {\r\n                if (!breakFlag) {\r\n                    placeZombie()\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            zombieOccupiedHexes = []\r\n            for (let i=0; i<100; i++) {\r\n                if (zombieHeadHexes[i]) {\r\n                    zombieOccupiedHexes.push(i)\r\n                    zombieOccupiedHexes = zombieOccupiedHexes.concat(zombieHeadHexes[i])\r\n                }\r\n            }\r\n        }\r\n\r\n        function slotsAlgorithm() {\r\n            //This is the third algorithm for deciding where to put the zombies.\r\n            //Each number of zombie arms has its own set of slots. Each zombie occupies one slot.\r\n            //For each zombie:\r\n            //1. A slot is randomly chosen from the set of unoccupied slots with the current maximum number of hexes.\r\n            //2. repeat\r\n            let slotArray = [\r\n                [ //0 arms\r\n                    []      //slot set 0\r\n                ],\r\n                [[]], //1 arm\r\n                [ //2 arms\r\n                    [   // slot set 0 (2 arms)\r\n                        [19, [9, 29]],\r\n                        [49, [39, 59]],\r\n                        [79, [69, 89]]\r\n                    ],      \r\n                    [  //slot set 1 (0 arms)         \r\n                        [99, []]\r\n                    ] \r\n                ],\r\n                [[]], //3 arms\r\n                [[]], //4 arms\r\n            ]\r\n            //building the sets of slots\r\n            let headPosition;\r\n            if (numZombieArms===0) {\r\n                for (let i=0; i<100; i++) {\r\n                    slotArray[0][0][i] = [i, []]\r\n                }\r\n            } else if (numZombieArms===1) {\r\n                for (let i=0; i<50; i++) {\r\n                    slotArray[1][0][i] = [2*i, [2*i+1]]\r\n                }\r\n            } else if (numZombieArms===2) {\r\n                headPosition = 1\r\n                for (let i=0; i<30; i++) {\r\n                    slotArray[2][0][i+3] = [headPosition, [headPosition-1, headPosition+1]]\r\n                    headPosition += 3\r\n                    if (headPosition%10===0) headPosition++\r\n                }\r\n            } else if (numZombieArms===3) {\r\n                headPosition = 1\r\n                for (let i=0; i<25; i++) {\r\n                    slotArray[3][0][i] = [headPosition, [headPosition-1, headPosition+9, headPosition+10]]\r\n                    headPosition += 2\r\n                    if (((headPosition - headPosition%10)/10)%2) headPosition += 10\r\n                }\r\n            } else if (numZombieArms===4) {\r\n                headPosition = 1\r\n                for (let i=0; i<20; i++) {\r\n                    if (i<10) {\r\n                        slotArray[4][0][i] = \r\n                            [\r\n                                headPosition,\r\n                                [headPosition-1, headPosition+9, headPosition+10, headPosition+1]\r\n                            ]\r\n                        headPosition += 5\r\n                        if (((headPosition - headPosition%10)/10)%2) headPosition += 10\r\n                    } else {\r\n                        if (i===10) headPosition = 13\r\n                        slotArray[4][0][i] = \r\n                            [\r\n                                headPosition,\r\n                                [headPosition-1, headPosition-10, headPosition-9, headPosition+1]\r\n                            ]\r\n                        headPosition += 5\r\n                        if (!(((headPosition - headPosition%10)/10)%2)) headPosition += 10\r\n                    }\r\n                }\r\n            }\r\n            \r\n            let currentSlots = arrayCopy(slotArray[numZombieArms][0])\r\n            for (let i=0; i<zombieCount; i++) {\r\n                console.log(\"placing zombie #\", i)\r\n                if (currentSlots.length===0 && !slotArray[numZombieArms][1]) break;\r\n                else if (currentSlots.length===0) currentSlots = slotArray[numZombieArms][1]\r\n                let chosenIndex = randomInteger(0, currentSlots.length - 1)\r\n                let chosenSlot = currentSlots[chosenIndex]\r\n                console.log(\"chosen zombie:\", chosenSlot)\r\n                let chosenHead = chosenSlot[0]\r\n                let chosenArms = chosenSlot[1]\r\n    \r\n                zombieHeadHexes[chosenHead] = chosenArms\r\n                zombieOccupiedHexes.push(chosenHead)\r\n                zombieOccupiedHexes = zombieOccupiedHexes.concat(chosenArms)\r\n                currentSlots = deleteAtIndex(currentSlots, chosenIndex)\r\n            }\r\n        }\r\n\r\n        //------//\r\n\r\n        if (stateObject.algorithm===\"random-head\") randomHeadAlgorithm()\r\n        else if (stateObject.algorithm===\"slide\") slideAlgorithm()\r\n        else if (stateObject.algorithm===\"slots\") slotsAlgorithm()\r\n\r\n        //-----//\r\n\r\n        if (stateObject.mode===\"hotseat\") { \r\n            // zombieCount = 0 ?\r\n            this.setState(\r\n                {\r\n                    whoseTurn: \"wait\",\r\n                    humanOccupiedHexes: stateObject.hiddenHumanHexes,\r\n                    vaccinatedOccupiedHexes: stateObject.hiddenVaccinatedHexes\r\n                }\r\n            )\r\n            this.calcNewInfections(this.state)\r\n        }\r\n\r\n        this.setState(\r\n            {\r\n                zombieHeadHexes: zombieHeadHexes,\r\n                zombieOccupiedHexes: zombieOccupiedHexes,\r\n                zombieCount: zombieCount\r\n\r\n            }\r\n        )\r\n\r\n        return {\r\n            zombieHeadHexes: zombieHeadHexes,\r\n            zombieOccupiedHexes: zombieOccupiedHexes\r\n        }\r\n    }\r\n\r\n    nextRoundHotseat() {\r\n        if ((this.state.humanCount===0 && this.state.vaccinatedCount===0) || this.state.zombieCount===0) return\r\n        this.setState(\r\n            {\r\n                whoseTurn: \"Humans\",\r\n                humanOccupiedHexes: [],\r\n                vaccinatedOccupiedHexes: [],\r\n                zombieOccupiedHexes: [],\r\n                zombieHeadHexes: []\r\n            }\r\n        )\r\n    }\r\n\r\n    calcNewInfections(inputObject) {\r\n        let stateObject = this.state\r\n        let roundsCompleted = stateObject.roundsCompleted\r\n        let vaccineEffectiveness = stateObject.vaccineEffectiveness\r\n        let mortality = stateObject.mortality\r\n        let mortalityNum = stateObject.mortalityNum\r\n\r\n        let history = inputObject.history\r\n        let humanCount = history[roundsCompleted].humanCount\r\n        let vaccinatedCount = history[roundsCompleted].vaccinatedCount\r\n        let zombieCount = history[roundsCompleted].zombieCount\r\n        let humanOccupiedHexes = inputObject.humanOccupiedHexes\r\n        let vaccinatedOccupiedHexes = inputObject.vaccinatedOccupiedHexes\r\n        if (stateObject.mode===\"hotseat\") {\r\n            humanOccupiedHexes = stateObject.hiddenHumanHexes\r\n            vaccinatedOccupiedHexes = stateObject.hiddenVaccinatedHexes\r\n        }\r\n        let zombieOccupiedHexes = inputObject.zombieOccupiedHexes\r\n\r\n        if (mortality && roundsCompleted >= mortalityNum) {\r\n            zombieCount -= history[roundsCompleted - mortalityNum].newInfections\r\n        }\r\n\r\n        let infectedVaccinatedHexes = []\r\n        let newInfections = 0\r\n        let newVaccinatedInfections = 0\r\n        for (let hex of zombieOccupiedHexes) {\r\n            if (humanOccupiedHexes.includes(hex)) newInfections++\r\n            if (vaccinatedOccupiedHexes.includes(hex)) {\r\n                let roll = Math.random()\r\n                if (roll>=(vaccineEffectiveness/100)) {\r\n                    newVaccinatedInfections++\r\n                    infectedVaccinatedHexes.push(hex)\r\n                }\r\n            }\r\n        }\r\n        humanCount -= newInfections\r\n        vaccinatedCount -= newVaccinatedInfections\r\n        zombieCount += (newInfections + newVaccinatedInfections)\r\n        roundsCompleted++\r\n        history[roundsCompleted] = \r\n            {\r\n                humanCount: humanCount,\r\n                zombieCount: zombieCount,\r\n                newInfections: newInfections + newVaccinatedInfections,\r\n                vaccinatedCount: vaccinatedCount\r\n            }\r\n        if (mortality && roundsCompleted >= mortalityNum) { //we have to do this twice because the\r\n                //first time took from history, which is before we subtracted\r\n            zombieCount -= history[roundsCompleted - mortalityNum].newInfections\r\n            if (zombieCount===0) {\r\n                history.push(\r\n                    {\r\n                        humanCount: humanCount,\r\n                        zombieCount: 0,\r\n                        newInfections: 0,\r\n                        vaccinatedCount: vaccinatedCount\r\n                    }\r\n                )\r\n            }\r\n        }\r\n        this.setState(\r\n            {\r\n                zombieCount: zombieCount,\r\n                humanCount: humanCount,\r\n                vaccinatedCount: vaccinatedCount,\r\n                roundsCompleted: roundsCompleted,\r\n                history: history,\r\n                infectedVaccinatedHexes: infectedVaccinatedHexes,\r\n                theGraph: this.createGraph(\r\n                    history,\r\n                    stateObject.vaccination,\r\n                    mortality\r\n                )\r\n            }\r\n        )\r\n    }\r\n\r\n    restart() {\r\n        this.setState(\r\n            {\r\n                roundsCompleted: 0,\r\n                humanOccupiedHexes: [],\r\n                zombieOccupiedHexes: [],\r\n                vaccinatedOccupiedHexes: [],\r\n                zombieHeadHexes: makeZeroesArray(100),\r\n                humanCount: this.state.history[0].humanCount || 50,\r\n                vaccinatedCount: this.state.history[0].vaccinatedCount || 0,\r\n                zombieCount: this.state.history[0].zombieCount || 1,\r\n                history: [],\r\n                gameStarted: false,\r\n                whoseTurn: \"Humans\",\r\n                placeHeadOrArm: \"head\",\r\n                currentHeadHex: 0,\r\n                numArmsRemaining: 0,\r\n                theGraph: null\r\n            }\r\n        )\r\n    }\r\n\r\n//------------------------------------------------------------------------------------------------------------------------//\r\n\r\n//------------------------------------------------------------------------------------------------------------------------//\r\n\r\n    render() {\r\n        return (\r\n            <div id=\"outer\">\r\n                <div id=\"main\">\r\n                    {this.displayBoard(this.state)}\r\n                    <div id=\"middle-div\">\r\n                        {this.displayControls(this.state)}\r\n                        {this.displayStatusInfo(this.state)}\r\n                    </div>\r\n                    <div id=\"data\">\r\n                        {this.displayHistoryTable(this.state.history, this.state.gameStarted)}\r\n                        {this.state.theGraph}\r\n                    </div>\r\n                </div>\r\n                <label id=\"reference\">\r\n                    Based on a game concept by Jim Powell and Matt Lewis: <a href=\r\n                    \"https://digitalcommons.usu.edu/lemb/1/\">https://digitalcommons.usu.edu/lemb/1/</a>.\r\n                </label>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------------------------------------------------//\r\n\r\n//------------------------------------------------------------------------------------------------------------------------//\r\n\r\nfunction randomInteger(min, max) {\r\n    let range = max - min + 1\r\n    return Math.floor(range*(Math.random())) + min\r\n}\r\n\r\nfunction deleteAtIndex(array, index) { //someArray===[\"apple\", \"banana\", \"cheese\"]; deleteAtIndex(someArray, 1) => [\"apple\", \"cheese\"]\r\n    if (index>=array.length || index<0) throw (\"error\", array, index)\r\n    return array.slice(0, index).concat(array.slice(index + 1, array.length))\r\n}\r\n\r\nfunction makeCountArray(length) { //makeCountArray(4) => [0,1,2,3]\r\n    let returnArray = []\r\n    for (let i=0; i<length; i++) returnArray[i] = i\r\n    return returnArray\r\n}\r\n\r\nfunction makeZeroesArray(length) { //makeZeroesArray(4) => [null, null, null, null]\r\n    let returnArray = []\r\n    for (let i=0; i<length; i++) returnArray[i] = 0\r\n    return returnArray\r\n}\r\n\r\nfunction findSurroundingHexes(hex) {\r\n    let surroundingHexes;\r\n    if (((hex-hex%10)/10)%2) {//if it's an odd column\r\n        surroundingHexes = [hex-1, hex+10, hex+11, hex+1, hex-9, hex-10]\r\n    } else {                                //even column\r\n        surroundingHexes = [hex-1, hex+9, hex+10, hex+1, hex-10, hex-11]\r\n    }\r\n    if (hex%10===0) { //if it's on the top (get rid of stuff above)\r\n        surroundingHexes[0] = null\r\n        if (!(((hex-hex%10)/10)%2)) {  //if it's an even column\r\n            surroundingHexes[1] = null\r\n            surroundingHexes[5] = null\r\n        }   \r\n    } else if (hex%10===9) { //if it's on the bottom (get rid of stuff below)\r\n        surroundingHexes[3] = null\r\n        if (((hex-hex%10)/10)%2) { //odd column\r\n            surroundingHexes[2] = null\r\n            surroundingHexes[4] = null\r\n        }\r\n    }\r\n    if (hex<10) { //left side (get rid of stuff on the left)\r\n        surroundingHexes[4] = null\r\n        surroundingHexes[5] = null\r\n    } else if (hex>=90) { //right side (get rid of stuff on the right)\r\n        surroundingHexes[1] = null\r\n        surroundingHexes[2] = null\r\n    }\r\n\r\n    let returnArray = []\r\n    for (let anotherHex of surroundingHexes) {\r\n        if (anotherHex!==null) {\r\n            returnArray.push(anotherHex)\r\n        }\r\n    }\r\n    return returnArray\r\n}\r\n\r\nfunction arrayCopy(array) {\r\n    let returnArray = []\r\n    for (let element of array) {\r\n        returnArray.push(element)\r\n    }\r\n    return returnArray\r\n}\r\n\r\nfunction hPosition(hex) {\r\n    return (hex - hex%10)/10\r\n}\r\n\r\nfunction vPosition(hex) {\r\n    return hex%10\r\n}\r\n\r\nfunction isASubset(smallArray, bigArray) {\r\n    for (let value of smallArray) {\r\n        if (!bigArray.includes(value)) return false\r\n    }\r\n    return true\r\n}\r\n\r\nexport default App;\r\n\r\n//graph","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();"],"sourceRoot":""}